# -*- coding: utf-8 -*-
"""drone_delivery_simulator.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C6PGKLWpn8TP6UV9szirW6j4f4cIzx1D
"""

"""
Drone Delivery Simulator - Consolidated Version
Includes all components in a single file:
- Camera-based obstacle detection (TensorFlow Lite)
- Route optimization (A* Algorithm)
- DJI Drone SDK integration (simulated)
- Multi-drone coordination
- Machine Learning for dynamic rerouting
- Weather simulation & emergency handling
- Performance optimizations
"""

import time
import threading
import json
import math
import random
import heapq
from typing import Dict, List, Tuple, Optional, Set
from dataclasses import dataclass
import numpy as np
try:
    import tensorflow as tf
except ImportError:
    tf = None

# ==================== CONFIGURATION ====================
class Settings:
    # Drone settings
    MAX_DRONES = 5
    DRONE_CAPACITY = 2.0  # kg
    MAX_SPEED = 15.0  # m/s
    BATTERY_LIFE = 1800  # seconds

    # Map settings
    MAP_DATA = {
        "nodes": [
            {"lat": 0, "lon": 0, "neighbors": [{"lat": 0.0001, "lon": 0}, {"lat": 0, "lon": 0.0001}]},
            {"lat": 0.0001, "lon": 0, "neighbors": [{"lat": 0, "lon": 0}, {"lat": 0.0001, "lon": 0.0001}]},
            {"lat": 0, "lon": 0.0001, "neighbors": [{"lat": 0, "lon": 0}, {"lat": 0.0001, "lon": 0.0001}]},
            {"lat": 0.0001, "lon": 0.0001, "neighbors": [{"lat": 0.0001, "lon": 0}, {"lat": 0, "lon": 0.0001}]}
        ]
    }

    # TensorFlow Lite model (simulated)
    OBSTACLE_MODEL = None

    # Performance settings
    UPDATE_INTERVAL = 1.0  # seconds
    SIMULATION_SPEED = 1.0  # 1.0 = realtime

settings = Settings()

# ==================== DATA STRUCTURES ====================
@dataclass
class DeliveryRequest:
    package_id: str
    pickup_location: tuple  # (lat, lon)
    delivery_location: tuple  # (lat, lon)
    weight: float  # kg
    priority: int  # 1-5 (1 highest)
    deadline: float  # hours from now

# ==================== A* ROUTE OPTIMIZATION ====================
class AStarRouter:
    def __init__(self, map_data: Dict):
        """Initialize with map data"""
        self.map_data = map_data
        self.graph = self._build_graph(self.map_data)
        self.obstacles = set()

    def _build_graph(self, map_data: Dict) -> Dict[Tuple, Dict[Tuple, float]]:
        """Build graph from map data"""
        graph = {}
        for node in map_data['nodes']:
            pos = (node['lat'], node['lon'])
            graph[pos] = {}

            for neighbor in node['neighbors']:
                n_pos = (neighbor['lat'], neighbor['lon'])
                distance = self._haversine(pos, n_pos)
                graph[pos][n_pos] = distance

        return graph

    def _haversine(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:
        """Calculate distance between two GPS coordinates"""
        lat1, lon1 = pos1
        lat2, lon2 = pos2

        # Convert to radians
        lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])

        # Haversine formula
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2
        c = 2 * math.asin(math.sqrt(a))
        r = 6371  # Earth radius in km
        return c * r * 1000  # Convert to meters

    def find_route(self,
                  start: Tuple[float, float],
                  end: Tuple[float, float],
                  avoid_obstacles: bool = True,
                  weather: Optional[Dict] = None,
                  emergency: bool = False) -> Optional[List[Tuple[float, float]]]:
        """Find optimal route using A* algorithm"""
        if weather is None:
            weather = {}

        # Check if start or end are in obstacles
        if avoid_obstacles and (start in self.obstacles or end in self.obstacles):
            return None

        # Priority queue: (f_score, g_score, current, path)
        open_set = []
        heapq.heappush(open_set, (0, 0, start, [start]))

        # Visited nodes
        closed_set = set()

        while open_set:
            _, g_score, current, path = heapq.heappop(open_set)

            if current == end:
                return path

            if current in closed_set:
                continue

            closed_set.add(current)

            for neighbor, distance in self.graph.get(current, {}).items():
                if avoid_obstacles and neighbor in self.obstacles:
                    continue

                # Adjust distance based on weather conditions
                adjusted_distance = self._adjust_for_weather(distance, weather, emergency)

                new_g_score = g_score + adjusted_distance
                new_path = path + [neighbor]

                # Calculate heuristic (Haversine distance)
                h_score = self._haversine(neighbor, end)

                # Adjust heuristic for emergency situations
                if emergency:
                    h_score *= 0.8  # Prefer more direct routes in emergencies

                f_score = new_g_score + h_score
                heapq.heappush(open_set, (f_score, new_g_score, neighbor, new_path))

        return None

    def _adjust_for_weather(self, distance: float, weather: Dict, emergency: bool) -> float:
        """Adjust distance based on weather conditions"""
        wind_factor = 1.0
        rain_factor = 1.0

        if 'wind_speed' in weather:
            # Increase distance based on wind speed (headwind)
            wind_speed = weather['wind_speed']
            wind_factor = 1 + (wind_speed / 10)  # 10 m/s wind = 2x distance

        if 'rain_intensity' in weather:
            # Increase distance based on rain intensity
            rain_intensity = weather['rain_intensity']
            rain_factor = 1 + (rain_intensity / 5)  # 5 mm/h rain = 2x distance

        # In emergency, prioritize speed over energy efficiency
        if emergency:
            return distance * max(wind_factor, rain_factor)
        else:
            return distance * wind_factor * rain_factor

    def add_obstacle(self, position: Tuple[float, float]):
        """Add an obstacle to avoid"""
        self.obstacles.add(position)

    def clear_obstacles(self):
        """Clear all obstacles"""
        self.obstacles.clear()

# ==================== DJI DRONE CONTROLLER ====================
class DJIDroneController:
    def __init__(self,
                 drone_id: str,
                 max_capacity: float,
                 max_speed: float,
                 battery_life: float):
        """Initialize drone controller"""
        self.drone_id = drone_id
        self.max_capacity = max_capacity
        self.max_speed = max_speed
        self.max_battery = battery_life
        self.battery_level = 1.0  # 0.0-1.0

        # Current status
        self.position = (0.0, 0.0)  # (lat, lon)
        self.altitude = 0.0  # meters
        self.speed = 0.0  # m/s
        self.is_flying = False
        self.current_load = 0.0  # kg
        self.current_route = None
        self.current_delivery = None
        self.detected_obstacle = False

        # Camera and sensors
        self.camera_frame = None
        self.obstacle_distance = float('inf')

        # Start background tasks
        self._running = True
        threading.Thread(target=self._update_battery, daemon=True).start()
        threading.Thread(target=self._update_position, daemon=True).start()
        threading.Thread(target=self._obstacle_detection, daemon=True).start()

    def connect(self):
        """Connect to drone"""
        print(f"{self.drone_id}: Connecting to drone...")
        time.sleep(1)
        print(f"{self.drone_id}: Connected")

    def disconnect(self):
        """Disconnect from drone"""
        print(f"{self.drone_id}: Disconnecting...")
        self._running = False
        time.sleep(0.5)
        print(f"{self.drone_id}: Disconnected")

    def take_off(self):
        """Take off to default altitude"""
        if not self.is_flying:
            print(f"{self.drone_id}: Taking off...")
            time.sleep(2)
            self.is_flying = True
            self.altitude = 10.0  # meters
            print(f"{self.drone_id}: Taken off to {self.altitude}m")

    def land(self):
        """Land the drone"""
        if self.is_flying:
            print(f"{self.drone_id}: Landing...")
            time.sleep(2)
            self.is_flying = False
            self.altitude = 0.0
            self.speed = 0.0
            print(f"{self.drone_id}: Landed")

    def emergency_land(self):
        """Perform emergency landing"""
        print(f"{self.drone_id}: EMERGENCY LANDING!")
        self.is_flying = False
        self.altitude = 0.0
        self.speed = 0.0
        self.current_route = None

    def load_package(self, weight: float):
        """Load a package"""
        if weight > self.max_capacity:
            raise ValueError(f"Package too heavy (max {self.max_capacity}kg)")

        self.current_load = weight
        print(f"{self.drone_id}: Loaded {weight}kg package")

    def unload_package(self):
        """Unload current package"""
        print(f"{self.drone_id}: Unloaded {self.current_load}kg package")
        self.current_load = 0.0

    def follow_route(self, route: List[Tuple[float, float]]):
        """Follow a route of GPS coordinates"""
        if not route:
            return

        self.current_route = route
        print(f"{self.drone_id}: Following route with {len(route)} waypoints")

        for waypoint in route:
            if not self._running:
                break

            # Simulate movement to waypoint
            distance = self._calculate_distance(self.position, waypoint)
            time_needed = distance / self.max_speed

            # Update position gradually
            steps = max(5, int(time_needed / 0.1))  # Update every 0.1s
            lat_step = (waypoint[0] - self.position[0]) / steps
            lon_step = (waypoint[1] - self.position[1]) / steps

            for _ in range(steps):
                if not self._running or self.detected_obstacle:
                    break

                self.position = (
                    self.position[0] + lat_step,
                    self.position[1] + lon_step
                )
                time.sleep(0.1 * settings.SIMULATION_SPEED)

            if self.detected_obstacle:
                print(f"{self.drone_id}: Obstacle detected!")
                break

        self.current_route = None

    def get_position(self) -> Tuple[float, float]:
        """Get current position"""
        return self.position

    def _calculate_distance(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:
        """Calculate distance between two positions (simplified)"""
        return ((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)**0.5 * 111000  # Approx meters

    def _update_battery(self):
        """Simulate battery drain"""
        while self._running:
            if self.is_flying:
                # Base drain + additional based on load
                drain_rate = 0.001 * (1 + self.current_load / self.max_capacity)
                self.battery_level = max(0, self.battery_level - drain_rate)

                if self.battery_level <= 0:
                    print(f"{self.drone_id}: Battery depleted!")
                    self.emergency_land()

            time.sleep(1 * settings.SIMULATION_SPEED)

    def _update_position(self):
        """Update position based on current movement"""
        while self._running:
            time.sleep(0.1 * settings.SIMULATION_SPEED)

    def _obstacle_detection(self):
        """Simulate obstacle detection"""
        while self._running:
            # Randomly simulate obstacle detection
            self.detected_obstacle = random.random() < 0.01  # 1% chance per check
            if self.detected_obstacle:
                self.obstacle_distance = random.uniform(1.0, 10.0)
                time.sleep(2 * settings.SIMULATION_SPEED)
                self.detected_obstacle = False
            else:
                self.obstacle_distance = float('inf')

            time.sleep(0.5 * settings.SIMULATION_SPEED)

# ==================== WEATHER SIMULATION ====================
class WeatherSimulator:
    def __init__(self):
        """Initialize weather simulation"""
        self.current_weather = self._generate_weather()
        self._running = True
        threading.Thread(target=self._update_weather, daemon=True).start()

    def get_current_weather(self) -> Dict:
        """Get current weather conditions"""
        return self.current_weather

    def _generate_weather(self) -> Dict:
        """Generate random weather conditions"""
        weather_types = ['clear', 'cloudy', 'rainy', 'stormy']
        weather = random.choice(weather_types)

        conditions = {
            'weather': weather,
            'temperature': random.uniform(-5, 35),  # Celsius
            'wind_speed': random.uniform(0, 15),  # m/s
            'wind_direction': random.uniform(0, 360),  # degrees
            'visibility': random.uniform(100, 10000)  # meters
        }

        if weather == 'rainy':
            conditions['rain_intensity'] = random.uniform(1, 10)  # mm/h
        elif weather == 'stormy':
            conditions['rain_intensity'] = random.uniform(10, 50)  # mm/h
            conditions['wind_speed'] = random.uniform(15, 30)  # m/s

        return conditions

    def _update_weather(self):
        """Periodically update weather conditions"""
        while self._running:
            new_weather = self.current_weather.copy()

            for key in ['temperature', 'wind_speed', 'visibility']:
                new_weather[key] += random.uniform(-0.5, 0.5)
                new_weather[key] = max(0, new_weather[key])

            if random.random() < 0.1:
                self.current_weather = self._generate_weather()
            else:
                self.current_weather = new_weather

            time.sleep(60 * settings.SIMULATION_SPEED)

# ==================== ML REROUTING ====================
class ReroutingPredictor:
    def __init__(self):
        """Initialize ML model for rerouting predictions"""
        self.model_loaded = False
        if tf is not None:
            self._load_model()

    def _load_model(self):
        """Load TensorFlow Lite model (simulated)"""
        print("Rerouting ML model initialized (simulated)")
        self.model_loaded = True

    def predict_reroute(self,
                      current_pos: Tuple[float, float],
                      destination: Tuple[float, float],
                      original_route: List[Tuple[float, float]],
                      weather: Dict) -> Optional[List[Tuple[float, float]]]:
        """Predict an optimal reroute around obstacles (simulated)"""
        if not self.model_loaded:
            return None

        try:
            # Simulate a slightly different route
            if len(original_route) > 2:
                mid_point = (
                    (original_route[1][0] + random.uniform(-0.00005, 0.00005)),
                    (original_route[1][1] + random.uniform(-0.00005, 0.00005))
                )
                return [current_pos, mid_point, destination]
            return None
        except Exception as e:
            print(f"Reroute prediction failed: {str(e)}")
            return None

# ==================== MULTI-DRONE COORDINATION ====================
class DroneCoordinator:
    def __init__(self, max_drones: int, drone_capacity: float):
        """Initialize drone coordinator"""
        self.max_drones = max_drones
        self.drone_capacity = drone_capacity
        self.drone_status = {}

    def register_drone(self, drone: DJIDroneController):
        """Register a drone with the coordinator"""
        self.drone_status[drone.drone_id] = {
            'available': True,
            'current_load': 0.0,
            'position': (0.0, 0.0),
            'battery': 1.0,
            'assigned_delivery': None
        }

    def find_available_drone(self,
                           current_location: Tuple[float, float],
                           required_capacity: float,
                           weather_conditions: Dict) -> Optional[str]:
        """Find an available drone for a delivery"""
        if required_capacity > self.drone_capacity:
            return None

        available_drones = [
            (drone_id, status)
            for drone_id, status in self.drone_status.items()
            if status['available']
            and (self.drone_capacity - status['current_load']) >= required_capacity
            and status['battery'] > 0.3
        ]

        if not available_drones:
            return None

        scored_drones = []
        for drone_id, status in available_drones:
            distance = self._calculate_distance(status['position'], current_location)
            distance_score = 1 / (1 + distance)
            battery_score = status['battery']
            weather_score = self._calculate_weather_score(status['position'], current_location, weather_conditions)

            total_score = (0.4 * distance_score + 0.3 * battery_score + 0.3 * weather_score)
            scored_drones.append((total_score, drone_id))

        scored_drones.sort(reverse=True)
        best_drone_id = scored_drones[0][1]
        self.drone_status[best_drone_id]['available'] = False
        self.drone_status[best_drone_id]['current_load'] += required_capacity
        return best_drone_id

    def _calculate_distance(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:
        """Calculate simplified distance between two points"""
        return ((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)**0.5

    def _calculate_weather_score(self,
                               drone_pos: Tuple[float, float],
                               target_pos: Tuple[float, float],
                               weather: Dict) -> float:
        """Calculate weather suitability score (0-1)"""
        wind_speed = weather.get('wind_speed', 0)
        rain_intensity = weather.get('rain_intensity', 0)
        wind_score = max(0, 1 - wind_speed / 20)
        rain_score = max(0, 1 - rain_intensity / 30)
        return (wind_score + rain_score) / 2

    def release_drone(self, drone_id: str):
        """Release a drone after delivery completion"""
        if drone_id in self.drone_status:
            self.drone_status[drone_id]['available'] = True
            self.drone_status[drone_id]['current_load'] = 0.0

# ==================== MAIN SIMULATOR ====================
class DroneDeliverySimulator:
    def __init__(self):
        # Initialize components
        self.router = AStarRouter(settings.MAP_DATA)
        self.weather = WeatherSimulator()
        self.reroute_predictor = ReroutingPredictor()
        self.coordinator = DroneCoordinator(
            max_drones=settings.MAX_DRONES,
            drone_capacity=settings.DRONE_CAPACITY
        )

        # Simulated drone fleet
        self.drones = {}
        self.setup_drones()

        # Delivery queue
        self.delivery_queue = []
        self.completed_deliveries = []
        self.failed_deliveries = []

        # Performance metrics
        self.metrics = {
            'deliveries_completed': 0,
            'average_delivery_time': 0,
            'obstacles_avoided': 0,
            'emergencies_handled': 0
        }

        # Start background threads
        self.running = True
        threading.Thread(target=self._monitor_drones, daemon=True).start()
        threading.Thread(target=self._process_queue, daemon=True).start()

    def setup_drones(self):
        """Initialize drone controllers"""
        for i in range(settings.MAX_DRONES):
            drone_id = f"DRONE-{i+1:03d}"
            self.drones[drone_id] = DJIDroneController(
                drone_id=drone_id,
                max_capacity=settings.DRONE_CAPACITY,
                max_speed=settings.MAX_SPEED,
                battery_life=settings.BATTERY_LIFE
            )
            self.coordinator.register_drone(self.drones[drone_id])

    def add_delivery_request(self, request: DeliveryRequest):
        """Add a new delivery to the queue"""
        self.delivery_queue.append(request)
        self.delivery_queue.sort(key=lambda x: (x.priority, x.deadline))

    def _process_queue(self):
        """Process delivery queue in background"""
        while self.running:
            if self.delivery_queue:
                request = self.delivery_queue.pop(0)
                self.assign_delivery(request)
            time.sleep(1)

    def assign_delivery(self, request: DeliveryRequest):
        """Assign delivery to an available drone"""
        drone_id = self.coordinator.find_available_drone(
            current_location=(0, 0),
            required_capacity=request.weight,
            weather_conditions=self.weather.get_current_weather()
        )

        if drone_id:
            drone = self.drones[drone_id]
            route = self.router.find_route(
                start=request.pickup_location,
                end=request.delivery_location,
                avoid_obstacles=True,
                weather=self.weather.get_current_weather()
            )

            if route:
                delivery_thread = threading.Thread(
                    target=self.execute_delivery,
                    args=(drone, request, route))
                delivery_thread.start()
            else:
                print(f"Failed to find route for {request.package_id}")
                self.failed_deliveries.append(request)
        else:
            print(f"No available drones for {request.package_id}")
            self.delivery_queue.insert(0, request)

    def execute_delivery(self, drone: DJIDroneController, request: DeliveryRequest, route: list):
        """Execute a delivery with a drone"""
        print(f"Starting delivery {request.package_id} with {drone.drone_id}")

        try:
            # Pickup phase
            drone.take_off()
            drone.follow_route(route[:len(route)//2])
            drone.load_package(request.weight)
            time.sleep(2)

            # Delivery phase
            drone.follow_route(route[len(route)//2:])
            drone.unload_package()
            time.sleep(1)

            # Return to base
            return_route = self.router.find_route(
                start=request.delivery_location,
                end=(0, 0),
                avoid_obstacles=True,
                weather=self.weather.get_current_weather()
            )
            drone.follow_route(return_route)
            drone.land()

            # Update metrics
            self.completed_deliveries.append(request)
            self.metrics['deliveries_completed'] += 1
            self.coordinator.release_drone(drone.drone_id)
            print(f"Completed delivery {request.package_id}")

        except Exception as e:
            print(f"Delivery failed: {str(e)}")
            self.failed_deliveries.append(request)
            self.coordinator.release_drone(drone.drone_id)
            self.handle_emergency(drone, request)

    def handle_emergency(self, drone: DJIDroneController, request: DeliveryRequest):
        """Handle emergency situations"""
        self.metrics['emergencies_handled'] += 1
        try:
            current_location = drone.get_position()
            return_route = self.router.find_route(
                start=current_location,
                end=(0, 0),
                avoid_obstacles=True,
                weather=self.weather.get_current_weather(),
                emergency=True
            )
            drone.follow_route(return_route)
            drone.land()
        except:
            drone.emergency_land()

    def _monitor_drones(self):
        """Monitor drone status in background"""
        while self.running:
            for drone in self.drones.values():
                if drone.battery_level < 0.2:
                    print(f"Low battery on {drone.drone_id}")
                    if hasattr(drone, 'current_delivery'):
                        self.handle_emergency(drone, drone.current_delivery)

                if drone.detected_obstacle:
                    self.metrics['obstacles_avoided'] += 1
                    self.reroute_around_obstacle(drone)

            time.sleep(5)

    def reroute_around_obstacle(self, drone: DJIDroneController):
        """Dynamically reroute around detected obstacle"""
        current_location = drone.get_position()
        destination = drone.current_route[-1] if drone.current_route else (0, 0)

        new_route = self.reroute_predictor.predict_reroute(
            current_location,
            destination,
            drone.current_route,
            self.weather.get_current_weather()
        )

        if new_route:
            drone.follow_route(new_route)
        else:
            new_route = self.router.find_route(
                start=current_location,
                end=destination,
                avoid_obstacles=True,
                weather=self.weather.get_current_weather()
            )
            if new_route:
                drone.follow_route(new_route)
            else:
                self.handle_emergency(drone, None)

    def shutdown(self):
        """Safely shutdown the simulator"""
        self.running = False
        for drone in self.drones.values():
            drone.land()
            drone.disconnect()

# ==================== MAIN EXECUTION ====================
if __name__ == "__main__":
    print("Starting Drone Delivery Simulator")
    simulator = DroneDeliverySimulator()

    # Sample delivery requests
    sample_request = DeliveryRequest(
        package_id="MED-001",
        pickup_location=(0.00005, 0.00005),  # Near base
        delivery_location=(0.0001, 0.0001),   # Nearby location
        weight=1.5,
        priority=1,
        deadline=2.0
    )

    simulator.add_delivery_request(sample_request)

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        simulator.shutdown()
        print("Simulator shutdown complete")

def setup_drones(self):
    """Initialize drone controllers"""
    for i in range(settings.MAX_DRONES):
        drone_id = f"DRONE-{i+1:03d}"
        self.drones[drone_id] = DJIDroneController(
            drone_id=drone_id,
            max_capacity=settings.DRONE_CAPACITY,
            max_speed=settings.MAX_SPEED,  # Assuming you have MAX_SPEED in settings
            battery_life=settings.BATTERY_LIFE  # Assuming you have BATTERY_LIFE in settings
        )

def setup_drones(self):
    """Initialize drone controllers"""
    # ... (previous code) ...

    # Print drone information (optional)
    for drone_id, drone in self.drones.items():
        print(f"Drone {drone_id} initialized with capacity {drone.max_capacity}, speed {drone.max_speed}, battery life {drone.battery_life}")

class Settings:
    # Drone settings
    MAX_DRONES = 5
    DRONE_CAPACITY = 2.0  # kg
    MAX_SPEED = 15.0  # m/s
    BATTERY_LIFE = 1800  # seconds

    # Map settings
    MAP_DATA = {
        "nodes": [
            {"lat": 0, "lon": 0, "neighbors": [{"lat": 0.0001, "lon": 0}, {"lat": 0, "lon": 0.0001}]},
            {"lat": 0.0001, "lon": 0, "neighbors": [{"lat": 0, "lon": 0}, {"lat": 0.0001, "lon": 0.0001}]},
            {"lat": 0, "lon": 0.0001, "neighbors": [{"lat": 0, "lon": 0}, {"lat": 0.0001, "lon": 0.0001}]},
            {"lat": 0.0001, "lon": 0.0001, "neighbors": [{"lat": 0.0001, "lon": 0}, {"lat": 0, "lon": 0.0001}]}
        ]
    }

    # TensorFlow Lite model (simulated)
    OBSTACLE_MODEL = None

    # Performance settings
    UPDATE_INTERVAL = 1.0  # seconds
    SIMULATION_SPEED = 1.0  # 1.0 = realtime

settings = Settings()

import math
import heapq
from typing import Dict, List, Tuple, Optional

class AStarRouter:
    def __init__(self, map_data: Dict):
        """Initialize with map data"""
        self.map_data = map_data
        self.graph = self._build_graph(self.map_data)
        self.obstacles = set()

    def _build_graph(self, map_data: Dict) -> Dict[Tuple, Dict[Tuple, float]]:
        """Build graph from map data"""
        graph = {}
        for node in map_data['nodes']:
            pos = (node['lat'], node['lon'])
            graph[pos] = {}

            for neighbor in node['neighbors']:
                n_pos = (neighbor['lat'], neighbor['lon'])
                distance = self._haversine(pos, n_pos)
                graph[pos][n_pos] = distance

        return graph

    def _haversine(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:
        """Calculate distance between two GPS coordinates"""
        lat1, lon1 = pos1
        lat2, lon2 = pos2

        # Convert to radians
        lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])

        # Haversine formula
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2
        c = 2 * math.asin(math.sqrt(a))
        r = 6371  # Earth radius in km
        return c * r * 1000  # Convert to meters

    def find_route(self,
                  start: Tuple[float, float],
                  end: Tuple[float, float],
                  avoid_obstacles: bool = True,
                  weather: Optional[Dict] = None,
                  emergency: bool = False) -> Optional[List[Tuple[float, float]]]:
        """Find optimal route using A* algorithm"""
        if weather is None:
            weather = {}

        # Check if start or end are in obstacles
        if avoid_obstacles and (start in self.obstacles or end in self.obstacles):
            return None

        # Priority queue: (f_score, g_score, current, path)
        open_set = []
        heapq.heappush(open_set, (0, 0, start, [start]))

        # Visited nodes
        closed_set = set()

        while open_set:
            _, g_score, current, path = heapq.heappop(open_set)

            if current == end:
                return path

            if current in closed_set:
                continue

            closed_set.add(current)

            for neighbor, distance in self.graph.get(current, {}).items():
                if avoid_obstacles and neighbor in self.obstacles:
                    continue

                # Adjust distance based on weather conditions
                adjusted_distance = self._adjust_for_weather(distance, weather, emergency)

                new_g_score = g_score + adjusted_distance
                new_path = path + [neighbor]

                # Calculate heuristic (Haversine distance)
                h_score = self._haversine(neighbor, end)

                # Adjust heuristic for emergency situations
                if emergency:
                    h_score *= 0.8  # Prefer more direct routes in emergencies

                f_score = new_g_score + h_score
                heapq.heappush(open_set, (f_score, new_g_score, neighbor, new_path))

        return None

    def _adjust_for_weather(self, distance: float, weather: Dict, emergency: bool) -> float:
        """Adjust distance based on weather conditions"""
        wind_factor = 1.0
        rain_factor = 1.0

        if 'wind_speed' in weather:
            # Increase distance based on wind speed (headwind)
            wind_speed = weather['wind_speed']
            wind_factor = 1 + (wind_speed / 10)  # 10 m/s wind = 2x distance

        if 'rain_intensity' in weather:
            # Increase distance based on rain intensity
            rain_intensity = weather['rain_intensity']
            rain_factor = 1 + (rain_intensity / 5)  # 5 mm/h rain = 2x distance

        # In emergency, prioritize speed over energy efficiency
        if emergency:
            return distance * max(wind_factor, rain_factor)
        else:
            return distance * wind_factor * rain_factor

    def add_obstacle(self, position: Tuple[float, float]):
        """Add an obstacle to avoid"""
        self.obstacles.add(position)

    def clear_obstacles(self):
        """Clear all obstacles"""
        self.obstacles.clear()

import time
import threading
import json
import math
import random
import heapq
from typing import Dict, List, Tuple, Optional, Set
from dataclasses import dataclass
import numpy as np
try:
    import tensorflow as tf
except ImportError:
    tf = None


class DJIDroneController:
    def __init__(self,
                 drone_id: str,
                 max_capacity: float,
                 max_speed: float,
                 battery_life: float):
        """Initialize drone controller"""
        self.drone_id = drone_id
        self.max_capacity = max_capacity
        self.max_speed = max_speed
        self.max_battery = battery_life
        self.battery_level = 1.0  # 0.0-1.0

        # Current status
        self.position = (0.0, 0.0)  # (lat, lon)
        self.altitude = 0.0  # meters
        self.speed = 0.0  # m/s
        self.is_flying = False
        self.current_load = 0.0  # kg
        self.current_route = None
        self.current_delivery = None
        self.detected_obstacle = False

        # Camera and sensors
        self.camera_frame = None
        self.obstacle_distance = float('inf')

        # Start background tasks
        self._running = True
        threading.Thread(target=self._update_battery, daemon=True).start()
        threading.Thread(target=self._update_position, daemon=True).start()
        threading.Thread(target=self._obstacle_detection, daemon=True).start()

    def connect(self):
        """Connect to drone"""
        print(f"{self.drone_id}: Connecting to drone...")
        time.sleep(1)
        print(f"{self.drone_id}: Connected")

    def disconnect(self):
        """Disconnect from drone"""
        print(f"{self.drone_id}: Disconnecting...")
        self._running = False
        time.sleep(0.5)
        print(f"{self.drone_id}: Disconnected")

    def take_off(self):
        """Take off to default altitude"""
        if not self.is_flying:
            print(f"{self.drone_id}: Taking off...")
            time.sleep(2)
            self.is_flying = True
            self.altitude = 10.0  # meters
            print(f"{self.drone_id}: Taken off to {self.altitude}m")

    def land(self):
        """Land the drone"""
        if self.is_flying:
            print(f"{self.drone_id}: Landing...")
            time.sleep(2)
            self.is_flying = False
            self.altitude = 0.0
            self.speed = 0.0
            print(f"{self.drone_id}: Landed")

    def emergency_land(self):
        """Perform emergency landing"""
        print(f"{self.drone_id}: EMERGENCY LANDING!")
        self.is_flying = False
        self.altitude = 0.0
        self.speed = 0.0
        self.current_route = None

    def load_package(self, weight: float):
        """Load a package"""
        if weight > self.max_capacity:
            raise ValueError(f"Package too heavy (max {self.max_capacity}kg)")

        self.current_load = weight
        print(f"{self.drone_id}: Loaded {weight}kg package")

    def unload_package(self):
        """Unload current package"""
        print(f"{self.drone_id}: Unloaded {self.current_load}kg package")
        self.current_load = 0.0

    def follow_route(self, route: List[Tuple[float, float]]):
        """Follow a route of GPS coordinates"""
        if not route:
            return

        self.current_route = route
        print(f"{self.drone_id}: Following route with {len(route)} waypoints")

        for waypoint in route:
            if not self._running:
                break

            # Simulate movement to waypoint
            distance = self._calculate_distance(self.position, waypoint)
            time_needed = distance / self.max_speed

            # Update position gradually
            steps = max(5, int(time_needed / 0.1))  # Update every 0.1s
            lat_step = (waypoint[0] - self.position[0]) / steps
            lon_step = (waypoint[1] - self.position[1]) / steps

            for _ in range(steps):
                if not self._running or self.detected_obstacle:
                    break

                self.position = (
                    self.position[0] + lat_step,
                    self.position[1] + lon_step
                )
                time.sleep(0.1 * settings.SIMULATION_SPEED)

            if self.detected_obstacle:
                print(f"{self.drone_id}: Obstacle detected!")
                break

        self.current_route = None

    def get_position(self) -> Tuple[float, float]:
        """Get current position"""
        return self.position

    def _calculate_distance(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:
        """Calculate distance between two positions (simplified)"""
        return ((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)**0.5 * 111000  # Approx meters

    def _update_battery(self):
        """Simulate battery drain"""
        while self._running:
            if self.is_flying:
                # Base drain + additional based on load
                drain_rate = 0.001 * (1 + self.current_load / self.max_capacity)
                self.battery_level = max(0, self.battery_level - drain_rate)

                if self.battery_level <= 0:
                    print(f"{self.drone_id}: Battery depleted!")
                    self.emergency_land()

            time.sleep(1 * settings.SIMULATION_SPEED)

    def _update_position(self):
        """Update position based on current movement"""
        while self._running:
            time.sleep(0.1 * settings.SIMULATION_SPEED)

    def _obstacle_detection(self):
        """Simulate obstacle detection"""
        while self._running:
            # Randomly simulate obstacle detection
            self.detected_obstacle = random.random() < 0.01  # 1% chance per check
            if self.detected_obstacle:
                self.obstacle_distance = random.uniform(1.0, 10.0)
                time.sleep(2 * settings.SIMULATION_SPEED)
                self.detected_obstacle = False
            else:
                self.obstacle_distance = float('inf')

            time.sleep(0.5 * settings.SIMULATION_SPEED)

import time
import threading
import random
from typing import Dict


class WeatherSimulator:
    def __init__(self):
        """Initialize weather simulation"""
        self.current_weather = self._generate_weather()
        self._running = True
        threading.Thread(target=self._update_weather, daemon=True).start()

    def get_current_weather(self) -> Dict:
        """Get current weather conditions"""
        return self.current_weather

    def _generate_weather(self) -> Dict:
        """Generate random weather conditions"""
        weather_types = ['clear', 'cloudy', 'rainy', 'stormy']
        weather = random.choice(weather_types)

        conditions = {
            'weather': weather,
            'temperature': random.uniform(-5, 35),  # Celsius
            'wind_speed': random.uniform(0, 15),  # m/s
            'wind_direction': random.uniform(0, 360),  # degrees
            'visibility': random.uniform(100, 10000)  # meters
        }

        if weather == 'rainy':
            conditions['rain_intensity'] = random.uniform(1, 10)  # mm/h
        elif weather == 'stormy':
            conditions['rain_intensity'] = random.uniform(10, 50)  # mm/h
            conditions['wind_speed'] = random.uniform(15, 30)  # m/s

        return conditions

    def _update_weather(self):
        """Periodically update weather conditions"""
        while self._running:
            new_weather = self.current_weather.copy()

            for key in ['temperature', 'wind_speed', 'visibility']:
                new_weather[key] += random.uniform(-0.5, 0.5)
                new_weather[key] = max(0, new_weather[key])

            if random.random() < 0.1:
                self.current_weather = self._generate_weather()
            else:
                self.current_weather = new_weather

            time.sleep(60 * settings.SIMULATION_SPEED)

from typing import Tuple, List, Optional, Dict
try:
    import tensorflow as tf
except ImportError:
    tf = None

class ReroutingPredictor:
    def __init__(self):
        """Initialize ML model for rerouting predictions"""
        self.model_loaded = False
        if tf is not None:
            self._load_model()

    def _load_model(self):
        """Load TensorFlow Lite model (simulated)"""
        print("Rerouting ML model initialized (simulated)")
        self.model_loaded = True

    def predict_reroute(self,
                      current_pos: Tuple[float, float],
                      destination: Tuple[float, float],
                      original_route: List[Tuple[float, float]],
                      weather: Dict) -> Optional[List[Tuple[float, float]]]:
        """Predict an optimal reroute around obstacles (simulated)"""
        if not self.model_loaded:
            return None

        try:
            # Simulate a slightly different route
            if len(original_route) > 2:
                mid_point = (
                    (original_route[1][0] + random.uniform(-0.00005, 0.00005)),
                    (original_route[1][1] + random.uniform(-0.00005, 0.00005))
                )
                return [current_pos, mid_point, destination]
            return None
        except Exception as e:
            print(f"Reroute prediction failed: {str(e)}")
            return None

!mkdir utils

from typing import Dict, Tuple, Optional, List

import time
import threading
import random

# ... (DJIDroneController class definition from ipython-input-48-7f0ba9ad5e8f) ...


class DroneCoordinator:
    def __init__(self, max_drones: int, drone_capacity: float):
        """Initialize drone coordinator"""
        self.max_drones = max_drones
        self.drone_capacity = drone_capacity
        self.drone_status = {}

    def register_drone(self, drone: DJIDroneController):  # Now DJIDroneController is accessible
        """Register a drone with the coordinator"""
        self.drone_status[drone.drone_id] = {
            'available': True,
            'current_load': 0.0,
            'position': (0.0, 0.0),
            'battery': 1.0,
            'assigned_delivery': None
        }

    def find_available_drone(self,
                           current_location: Tuple[float, float],
                           required_capacity: float,
                           weather_conditions: Dict) -> Optional[str]:
        """Find an available drone for a delivery"""
        if required_capacity > self.drone_capacity:
            return None

        available_drones = [
            (drone_id, status)
            for drone_id, status in self.drone_status.items()
            if status['available']
            and (self.drone_capacity - status['current_load']) >= required_capacity
            and status['battery'] > 0.3
        ]

        if not available_drones:
            return None

        scored_drones = []
        for drone_id, status in available_drones:
            distance = self._calculate_distance(status['position'], current_location)
            distance_score = 1 / (1 + distance)
            battery_score = status['battery']
            weather_score = self._calculate_weather_score(status['position'], current_location, weather_conditions)

            total_score = (0.4 * distance_score + 0.3 * battery_score + 0.3 * weather_score)
            scored_drones.append((total_score, drone_id))

        scored_drones.sort(reverse=True)
        best_drone_id = scored_drones[0][1]
        self.drone_status[best_drone_id]['available'] = False
        self.drone_status[best_drone_id]['current_load'] += required_capacity
        return best_drone_id

    def _calculate_distance(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:
        """Calculate simplified distance between two points"""
        return ((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)**0.5

    def _calculate_weather_score(self,
                               drone_pos: Tuple[float, float],
                               target_pos: Tuple[float, float],
                               weather: Dict) -> float:
        """Calculate weather suitability score (0-1)"""
        wind_speed = weather.get('wind_speed', 0)
        rain_intensity = weather.get('rain_intensity', 0)
        wind_score = max(0, 1 - wind_speed / 20)
        rain_score = max(0, 1 - rain_intensity / 30)
        return (wind_score + rain_score) / 2

    def release_drone(self, drone_id: str):
        """Release a drone after delivery completion"""
        if drone_id in self.drone_status:
            self.drone_status[drone_id]['available'] = True
            self.drone_status[drone_id]['current_load'] = 0.0

class DroneDeliverySimulator:
    def __init__(self):
        # Initialize components
        self.router = AStarRouter(settings.MAP_DATA)
        self.weather = WeatherSimulator()
        self.reroute_predictor = ReroutingPredictor()
        self.coordinator = DroneCoordinator(
            max_drones=settings.MAX_DRONES,
            drone_capacity=settings.DRONE_CAPACITY
        )

        # Simulated drone fleet
        self.drones = {}
        self.setup_drones()

        # Delivery queue
        self.delivery_queue = []
        self.completed_deliveries = []
        self.failed_deliveries = []

        # Performance metrics
        self.metrics = {
            'deliveries_completed': 0,
            'average_delivery_time': 0,
            'obstacles_avoided': 0,
            'emergencies_handled': 0
        }

        # Start background threads
        self.running = True
        threading.Thread(target=self._monitor_drones, daemon=True).start()
        threading.Thread(target=self._process_queue, daemon=True).start()

    def setup_drones(self):
        """Initialize drone controllers"""
        for i in range(settings.MAX_DRONES):
            drone_id = f"DRONE-{i+1:03d}"
            self.drones[drone_id] = DJIDroneController(
                drone_id=drone_id,
                max_capacity=settings.DRONE_CAPACITY,
                max_speed=settings.MAX_SPEED,
                battery_life=settings.BATTERY_LIFE
            )
            self.coordinator.register_drone(self.drones[drone_id])

    def add_delivery_request(self, request: DeliveryRequest): # Corrected indentation
        """Add a new delivery to the queue"""
        self.delivery_queue.append(request)
        self.delivery_queue.sort(key=lambda x: (x.priority, x.deadline))


    def _process_queue(self): # Corrected indentation
        """Process delivery queue in background"""
        while self.running:
            if self.delivery_queue:
                request = self.delivery_queue.pop(0)
                self.assign_delivery(request)
            time.sleep(1)

    def assign_delivery(self, request: DeliveryRequest):
        """Assign delivery to an available drone"""
        drone_id = self.coordinator.find_available_drone(
            current_location=(0, 0),
            required_capacity=request.weight,
            weather_conditions=self.weather.get_current_weather()
        )

        if drone_id:
            drone = self.drones[drone_id]
            route = self.router.find_route(
                start=request.pickup_location,
                end=request.delivery_location,
                avoid_obstacles=True,
                weather=self.weather.get_current_weather()
            )

            if route:
                delivery_thread = threading.Thread(
                    target=self.execute_delivery,
                    args=(drone, request, route))
                delivery_thread.start()
            else:
                print(f"Failed to find route for {request.package_id}")
                self.failed_deliveries.append(request)
        else:
            print(f"No available drones for {request.package_id}")
            self.delivery_queue.insert(0, request)

    def execute_delivery(self, drone: DJIDroneController, request: DeliveryRequest, route: list):
        """Execute a delivery with a drone"""
        print(f"Starting delivery {request.package_id} with {drone.drone_id}")

        try:
            # Pickup phase
            drone.take_off()
            drone.follow_route(route[:len(route)//2])
            drone.load_package(request.weight)
            time.sleep(2)

            # Delivery phase
            drone.follow_route(route[len(route)//2:])
            drone.unload_package()
            time.sleep(1)

            # Return to base
            return_route = self.router.find_route(
                start=request.delivery_location,
                end=(0, 0),
                avoid_obstacles=True,
                weather=self.weather.get_current_weather()
            )
            drone.follow_route(return_route)
            drone.land()

            # Update metrics
            self.completed_deliveries.append(request)
            self.metrics['deliveries_completed'] += 1
            self.coordinator.release_drone(drone.drone_id)
            print(f"Completed delivery {request.package_id}")

        except Exception as e:
            print(f"Delivery failed: {str(e)}")
            self.failed_deliveries.append(request)
            self.coordinator.release_drone(drone.drone_id)
            self.handle_emergency(drone, request)

    def handle_emergency(self, drone: DJIDroneController, request: DeliveryRequest):
        """Handle emergency situations"""
        self.metrics['emergencies_handled'] += 1
        try:
            current_location = drone.get_position()
            return_route = self.router.find_route(
                start=current_location,
                end=(0, 0),
                avoid_obstacles=True,
                weather=self.weather.get_current_weather(),
                emergency=True
            )
            drone.follow_route(return_route)
            drone.land()
        except:
            drone.emergency_land()

    def _monitor_drones(self):
        """Monitor drone status in background"""
        while self.running:
            for drone in self.drones.values():
                if drone.battery_level < 0.2:
                    print(f"Low battery on {drone.drone_id}")
                    if hasattr(drone, 'current_delivery'):
                        self.handle_emergency(drone, drone.current_delivery)

                if drone.detected_obstacle:
                    self.metrics['obstacles_avoided'] += 1
                    self.reroute_around_obstacle(drone)

            time.sleep(5)

    def reroute_around_obstacle(self, drone: DJIDroneController):
        """Dynamically reroute around detected obstacle"""
        current_location = drone.get_position()
        destination = drone.current_route[-1] if drone.current_route else (0, 0)

        new_route = self.reroute_predictor.predict_reroute(
            current_location,
            destination,
            drone.current_route,
            self.weather.get_current_weather()
        )

        if new_route:
            drone.follow_route(new_route)
        else:
            new_route = self.router.find_route(
                start=current_location,
                end=destination,
                avoid_obstacles=True,
                weather=self.weather.get_current_weather()
            )
            if new_route:
                drone.follow_route(new_route)
            else:
                self.handle_emergency(drone, None)

    def shutdown(self):
        """Safely shutdown the simulator"""
        self.running = False
        for drone in self.drones.values():
            drone.land()
            drone.disconnect()

!mkdir utils

# Commented out IPython magic to ensure Python compatibility.
# %%writefile utils/a_star.py
# import math
# import heapq
# from typing import Dict, List, Tuple, Optional
# 
# class AStarRouter:
#     def __init__(self, map_data: Dict):
#         """Initialize with map data"""
#         self.map_data = map_data
#         self.graph = self._build_graph(self.map_data)
#         self.obstacles = set()
# 
#     def _build_graph(self, map_data: Dict) -> Dict[Tuple, Dict[Tuple, float]]:
#         """Build graph from map data"""
#         graph = {}
#         for node in map_data['nodes']:
#             pos = (node['lat'], node['lon'])
#             graph[pos] = {}
# 
#             for neighbor in node['neighbors']:
#                 n_pos = (neighbor['lat'], neighbor['lon'])
#                 distance = self._haversine(pos, n_pos)
#                 graph[pos][n_pos] = distance
# 
#         return graph
# 
#     def _haversine(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:
#         """Calculate distance between two GPS coordinates"""
#         lat1, lon1 = pos1
#         lat2, lon2 = pos2
# 
#         # Convert to radians
#         lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])
# 
#         # Haversine formula
#         dlat = lat2 - lat1
#         dlon = lon2 - lon1
#         a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2
#         c = 2 * math.asin(math.sqrt(a))
#         r = 6371  # Earth radius in km
#         return c * r * 1000  # Convert to meters
# 
#     def find_route(self,
#                   start: Tuple[float, float],
#                   end: Tuple[float, float],
#                   avoid_obstacles: bool = True,
#                   weather: Optional[Dict] = None,
#                   emergency: bool = False) -> Optional[List[Tuple[float, float]]]:
#         """Find optimal route using A* algorithm"""
#         if weather is None:
#             weather = {}
# 
#         # Check if start or end are in obstacles
#         if avoid_obstacles and (start in self.obstacles or end in self.obstacles):
#             return None
# 
#         # Priority queue: (f_score, g_score, current, path)
#         open_set = []
#         heapq.heappush(open_set, (0, 0, start, [start]))
# 
#         # Visited nodes
#         closed_set = set()
# 
#         while open_set:
#             _, g_score, current, path = heapq.heappop(open_set)
# 
#             if current == end:
#                 return path
# 
#             if current in closed_set:
#                 continue
# 
#             closed_set.add(current)
# 
#             for neighbor, distance in self.graph.get(current, {}).items():
#                 if avoid_obstacles and neighbor in self.obstacles:
#                     continue
# 
#                 # Adjust distance based on weather conditions
#                 adjusted_distance = self._adjust_for_weather(distance, weather, emergency)
# 
#                 new_g_score = g_score + adjusted_distance
#                 new_path = path + [neighbor]
# 
#                 # Calculate heuristic (Haversine distance)
#                 h_score = self._haversine(neighbor, end)
# 
#                 # Adjust heuristic for emergency situations
#                 if emergency:
#                     h_score *= 0.8  # Prefer more direct routes in emergencies
# 
#                 f_score = new_g_score + h_score
#                 heapq.heappush(open_set, (f_score, new_g_score, neighbor, new_path))
# 
#         return None
# 
#     def _adjust_for_weather(self, distance: float, weather: Dict, emergency: bool) -> float:
#         """Adjust distance based on weather conditions"""
#         wind_factor = 1.0
#         rain_factor = 1.0
# 
#         if 'wind_speed' in weather:
#             # Increase distance based on wind speed (headwind)
#             wind_speed = weather['wind_speed']
#             wind_factor = 1 + (wind_speed / 10)  # 10 m/s wind = 2x distance
# 
#         if 'rain_intensity' in weather:
#             # Increase distance based on rain intensity
#             rain_intensity = weather['rain_intensity']
#             rain_factor = 1 + (rain_intensity / 5)  # 5 mm/h rain = 2x distance
# 
#         # In emergency, prioritize speed over energy efficiency
#         if emergency:
#             return distance * max(wind_factor, rain_factor)
#         else:
#             return distance * wind_factor * rain_factor
# 
#     def add_obstacle(self, position: Tuple[float, float]):
#         """Add an obstacle to avoid"""
#         self.obstacles.add(position)
# 
#     def clear_obstacles(self):
#         """Clear all obstacles"""
#         self.obstacles.clear()

# Update the import statement
from utils.a_star import AStarRouter # Updated import
# ... rest of the code

# Commented out IPython magic to ensure Python compatibility.
# %%writefile utils/drone_controller.py
# import time
# import threading
# import random
# from typing import Dict, List, Tuple, Optional
# from config import settings
# 
# class DJIDroneController:
#     def __init__(self,
#                  drone_id: str,
#                  max_capacity: float,
#                  max_speed: float,
#                  battery_life: float):
#         """Initialize drone controller"""
#         self.drone_id = drone_id
#         self.max_capacity = max_capacity
#         self.max_speed = max_speed
#         self.max_battery = battery_life
#         self.battery_level = 1.0  # 0.0-1.0
# 
#         # Current status
#         self.position = (0.0, 0.0)  # (lat, lon)
#         self.altitude = 0.0  # meters
#         self.speed = 0.0  # m/s
#         self.is_flying = False
#         self.current_load = 0.0  # kg
#         self.current_route = None
#         self.current_delivery = None
#         self.detected_obstacle = False
# 
#         # Camera and sensors
#         self.camera_frame = None
#         self.obstacle_distance = float('inf')
# 
#         # Start background tasks
#         self._running = True
#         threading.Thread(target=self._update_battery, daemon=True).start()
#         threading.Thread(target=self._update_position, daemon=True).start()
#         threading.Thread(target=self._obstacle_detection, daemon=True).start()
# 
#     def connect(self):
#         """Connect to drone"""
#         print(f"{self.drone_id}: Connecting to drone...")
#         time.sleep(1)
#         print(f"{self.drone_id}: Connected")
# 
#     def disconnect(self):
#         """Disconnect from drone"""
#         print(f"{self.drone_id}: Disconnecting...")
#         self._running = False
#         time.sleep(0.5)
#         print(f"{self.drone_id}: Disconnected")
# 
#     def take_off(self):
#         """Take off to default altitude"""
#         if not self.is_flying:
#             print(f"{self.drone_id}: Taking off...")
#             time.sleep(2)
#             self.is_flying = True
#             self.altitude = 10.0  # meters
#             print(f"{self.drone_id}: Taken off to {self.altitude}m")
# 
#     def land(self):
#         """Land the drone"""
#         if self.is_flying:
#             print(f"{self.drone_id}: Landing...")
#             time.sleep(2)
#             self.is_flying = False
#             self.altitude = 0.0
#             self.speed = 0.0
#             print(f"{self.drone_id}: Landed")
# 
#     def emergency_land(self):
#         """Perform emergency landing"""
#         print(f"{self.drone_id}: EMERGENCY LANDING!")
#         self.is_flying = False
#         self.altitude = 0.0
#         self.speed = 0.0
#         self.current_route = None
# 
#     def load_package(self, weight: float):
#         """Load a package"""
#         if weight > self.max_capacity:
#             raise ValueError(f"Package too heavy (max {self.max_capacity}kg)")
# 
#         self.current_load = weight
#         print(f"{self.drone_id}: Loaded {weight}kg package")
# 
#     def unload_package(self):
#         """Unload current package"""
#         print(f"{self.drone_id}: Unloaded {self.current_load}kg package")
#         self.current_load = 0.0
# 
#     def follow_route(self, route: List[Tuple[float, float]]):
#         """Follow a route of GPS coordinates"""
#         if not route:
#             return
# 
#         self.current_route = route
#         print(f"{self.drone_id}: Following route with {len(route)} waypoints")
# 
#         for waypoint in route:
#             if not self._running:
#                 break
# 
#             # Simulate movement to waypoint
#             distance = self._calculate_distance(self.position, waypoint)
#             time_needed = distance / self.max_speed
# 
#             # Update position gradually
#             steps = max(5, int(time_needed / 0.1))  # Update every 0.1s
#             lat_step = (waypoint[0] - self.position[0]) / steps
#             lon_step = (waypoint[1] - self.position[1]) / steps
# 
#             for _ in range(steps):
#                 if not self._running or self.detected_obstacle:
#                     break
# 
#                 self.position = (
#                     self.position[0] + lat_step,
#                     self.position[1] + lon_step
#                 )
#                 time.sleep(0.1 * settings.SIMULATION_SPEED)
# 
#             if self.detected_obstacle:
#                 print(f"{self.drone_id}: Obstacle detected!")
#                 break
# 
#         self.current_route = None
# 
#     def get_position(self) -> Tuple[float, float]:
#         """Get current position"""
#         return self.position
# 
#     def _calculate_distance(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:
#         """Calculate distance between two positions (simplified)"""
#         return ((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)**0.5 * 111000  # Approx meters
# 
#     def _update_battery(self):
#         """Simulate battery drain"""
#         while self._running:
#             if self.is_flying:
#                 # Base drain + additional based on load
#                 drain_rate = 0.001 * (1 + self.current_load / self.max_capacity)
#                 self.battery_level = max(0, self.battery_level - drain_rate)
# 
#                 if self.battery_level <= 0:
#                     print(f"{self.drone_id}: Battery depleted!")
#                     self.emergency_land()
# 
#             time.sleep(1 * settings.SIMULATION_SPEED)
# 
#     def _update_position(self):
#         """Update position based on current movement"""
#         while self._running:
#             time.sleep(0.1 * settings.SIMULATION_SPEED)
# 
#     def _obstacle_detection(self):
#         """Simulate obstacle detection"""
#         while self._running:
#             # Randomly simulate obstacle detection
#             self.detected_obstacle = random.random() < 0.01  # 1% chance per check
#             if self.detected_obstacle:
#                 self.obstacle_distance = random.uniform(1.0, 10.0)
#                 time.sleep(2 * settings.SIMULATION_SPEED)
#                 self.detected_obstacle = False
#             else:
#                 self.obstacle_distance = float('inf')
# 
#             time.sleep(0.5 * settings.SIMULATION_SPEED)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile utils/weather_sim.py
# import time
# import threading
# import random
# from typing import Dict
# 
# 
# class WeatherSimulator:
#     def __init__(self):
#         """Initialize weather simulation"""
#         self.current_weather = self._generate_weather()
#         self._running = True
#         threading.Thread(target=self._update_weather, daemon=True).start()
# 
#     def get_current_weather(self) -> Dict:
#         """Get current weather conditions"""
#         return self.current_weather
# 
#     def _generate_weather(self) -> Dict:
#         """Generate random weather conditions"""
#         weather_types = ['clear', 'cloudy', 'rainy', 'stormy']
#         weather = random.choice(weather_types)
# 
#         conditions = {
#             'weather': weather,
#             'temperature': random.uniform(-5, 35),  # Celsius
#             'wind_speed': random.uniform(0, 15),  # m/s
#             'wind_direction': random.uniform(0, 360),  # degrees
#             'visibility': random.uniform(100, 10000)  # meters
#         }
# 
#         if weather == 'rainy':
#             conditions['rain_intensity'] = random.uniform(1, 10)  # mm/h
#         elif weather == 'stormy':
#             conditions['rain_intensity'] = random.uniform(10, 50)  # mm/h
#             conditions['wind_speed'] = random.uniform(15, 30)  # m/s
# 
#         return conditions
# 
#     def _update_weather(self):
#         """Periodically update weather conditions"""
#         while self._running:
#             new_weather = self.current_weather.copy()
# 
#             for key in ['temperature', 'wind_speed', 'visibility']:
#                 new_weather[key] += random.uniform(-0.5, 0.5)
#                 new_weather[key] = max(0, new_weather[key])
# 
#             if random.random() < 0.1:
#                 self.current_weather = self._generate_weather()
#             else:
#                 self.current_weather = new_weather
# 
#             time.sleep(60 * settings.SIMULATION_SPEED) # Assuming you have settings imported from config.py

# Commented out IPython magic to ensure Python compatibility.
# %%writefile utils/ml_rerouting.py
# import random
# from typing import Dict, List, Tuple, Optional
# try:
#     import tensorflow as tf
# except ImportError:
#     tf = None
# 
# class ReroutingPredictor:
#     def __init__(self):
#         """Initialize ML model for rerouting predictions"""
#         self.model_loaded = False
#         if tf is not None:
#             self._load_model()
# 
#     def _load_model(self):
#         """Load TensorFlow Lite model (simulated)"""
#         print("Rerouting ML model initialized (simulated)")
#         self.model_loaded = True
# 
#     def predict_reroute(self,
#                       current_pos: Tuple[float, float],
#                       destination: Tuple[float, float],
#                       original_route: List[Tuple[float, float]],
#                       weather: Dict) -> Optional[List[Tuple[float, float]]]:
#         """Predict an optimal reroute around obstacles (simulated)"""
#         if not self.model_loaded:
#             return None
# 
#         try:
#             # Simulate a slightly different route
#             if len(original_route) > 2:
#                 mid_point = (
#                     (original_route[1][0] + random.uniform(-0.00005, 0.00005)),
#                     (original_route[1][1] + random.uniform(-0.00005, 0.00005))
#                 )
#                 return [current_pos, mid_point, destination]
#             return None
#         except Exception as e:
#             print(f"Reroute prediction failed: {str(e)}")
#             return None

# Commented out IPython magic to ensure Python compatibility.
# %%writefile utils/multi_drone.py
# from typing import Dict, List, Tuple, Optional
# from config import settings
# 
# class DroneCoordinator:
#     def __init__(self, max_drones: int, drone_capacity: float):
#         """Initialize drone coordinator"""
#         self.max_drones = max_drones
#         self.drone_capacity = drone_capacity
#         self.drone_status = {}
# 
#     def register_drone(self, drone):
#         """Register a drone with the coordinator"""
#         self.drone_status[drone.drone_id] = {
#             'available': True,
#             'current_load': 0.0,
#             'position': (0.0, 0.0),
#             'battery': 1.0,
#             'assigned_delivery': None
#         }
# 
#     def find_available_drone(self,
#                            current_location: Tuple[float, float],
#                            required_capacity: float,
#                            weather_conditions: Dict) -> Optional[str]:
#         """Find an available drone for a delivery"""
#         if required_capacity > self.drone_capacity:
#             return None
# 
#         available_drones = [
#             (drone_id, status)
#             for drone_id, status in self.drone_status.items()
#             if status['available']
#             and (self.drone_capacity - status['current_load']) >= required_capacity
#             and status['battery'] > 0.3
#         ]
# 
#         if not available_drones:
#             return None
# 
#         scored_drones = []
#         for drone_id, status in available_drones:
#             distance = self._calculate_distance(status['position'], current_location)
#             distance_score = 1 / (1 + distance)
#             battery_score = status['battery']
#             weather_score = self._calculate_weather_score(status['position'], current_location, weather_conditions)
# 
#             total_score = (0.4 * distance_score + 0.3 * battery_score + 0.3 * weather_score)
#             scored_drones.append((total_score, drone_id))
# 
#         scored_drones.sort(reverse=True)
#         best_drone_id = scored_drones[0][1]
#         self.drone_status[best_drone_id]['available'] = False
#         self.drone_status[best_drone_id]['current_load'] += required_capacity
#         return best_drone_id
# 
#     def _calculate_distance(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:
#         """Calculate simplified distance between two points"""
#         return ((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)**0.5
# 
#     def _calculate_weather_score(self,
#                                drone_pos: Tuple[float, float],
#                                target_pos: Tuple[float, float],
#                                weather: Dict) -> float:
#         """Calculate weather suitability score (0-1)"""
#         wind_speed = weather.get('wind_speed', 0)
#         rain_intensity = weather.get('rain_intensity', 0)
#         wind_score = max(0, 1 - wind_speed / 20)
#         rain_score = max(0, 1 - rain_intensity / 30)
#         return (wind_score + rain_score) / 2
# 
#     def release_drone(self, drone_id: str):
#         """Release a drone after delivery completion"""
#         if drone_id in self.drone_status:
#             self.drone_status[drone_id]['available'] = True
#             self.drone_status[drone_id]['current_load'] = 0.0

# Commented out IPython magic to ensure Python compatibility.
# %%writefile config.py
# from dataclasses import dataclass
# 
# @dataclass
# class DeliveryRequest:
#     package_id: str
#     pickup_location: tuple  # (lat, lon)
#     delivery_location: tuple  # (lat, lon)
#     weight: float  # kg
#     priority: int  # 1-5 (1 highest)
#     deadline: float  # hours from now
# 
# 
# class Settings:
#     # Drone settings
#     MAX_DRONES = 5
#     DRONE_CAPACITY = 2.0  # kg
#     MAX_SPEED = 15.0  # m/s
#     BATTERY_LIFE = 1800  # seconds
# 
#     # Map settings
#     MAP_DATA = {
#         "nodes": [
#             {"lat": 0, "lon": 0, "neighbors": [{"lat": 0.0001, "lon": 0}, {"lat": 0, "lon": 0.0001}]},
#             {"lat": 0.0001, "lon": 0, "neighbors": [{"lat": 0, "lon": 0}, {"lat": 0.0001, "lon": 0.0001}]},
#             {"lat": 0, "lon": 0.0001, "neighbors": [{"lat": 0, "lon": 0}, {"lat": 0.0001, "lon": 0.0001}]},
#             {"lat": 0.0001, "lon": 0.0001, "neighbors": [{"lat": 0.0001, "lon": 0}, {"lat": 0, "lon": 0.0001}]}
#         ]
#     }
# 
#     # TensorFlow Lite model (simulated)
#     OBSTACLE_MODEL = None
# 
#     # Performance settings
#     UPDATE_INTERVAL = 1.0  # seconds
#     SIMULATION_SPEED = 1.0  # 1.0 = realtime
# 
# settings = Settings()

